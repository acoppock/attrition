{
    "collab_server" : "",
    "contents" : "#' Extreme Value Bounds with Double Sampling\n#'\n#' @param Y The (unquoted) outcome variable. Must be numeric.\n#' @param Z The (unquoted) assignment indicator variable. Must be numeric and take values 0 or 1.\n#' @param R1 The (unquoted) initial sample respose indicator variable. Must be numeric and take values 0 or 1.\n#' @param Attempt The (unquoted) follow-up sample attempt indicator variable. Must be numeric and take values 0 or 1.\n#' @param R2 The (unquoted) follow-up sample respose indicator variable. Must be numeric and take values 0 or 1.\n#' @param minY The minimum possible value of the outcome (Y) variable.\n#' @param maxY The maximum possible value of the outcome (Y) variable.\n#' @param strata A single (unquoted) variable that indicates which strata units are in.\n#' @param alpha The desired significance level. 0.05 by default.\n#' @param data A dataframe\n#'\n#' @return A results matrix\n#' @export\n#'\n#' @examples\n#' set.seed(343) # For reproducibility\n#' N <- 1000\n#'\n#' # Potential Outcomes\n#' Y_0 <- sample(1:5, N, replace=TRUE, prob = c(0.1, 0.3, 0.3, 0.2, 0.1))\n#' Y_1 <- sample(1:5, N, replace=TRUE, prob = c(0.1, 0.1, 0.4, 0.3, 0.1))\n#'\n#' R1_0 <- rbinom(N, 1, prob = 0.7)\n#' R1_1 <- rbinom(N, 1, prob = 0.8)\n#'\n#' R2_0 <- rbinom(N, 1, prob = 0.9)\n#' R2_1 <- rbinom(N, 1, prob = 0.95)\n#'\n#' # Covariate\n#' strata <- as.numeric(Y_0 > 2)\n#'\n#' # Random Assignment\n#' Z <- rbinom(N, 1, .5)\n#'\n#' # Reveal Initial Sample Outcomes\n#' R1 <- Z*R1_1 + (1-Z)*R1_0 # Initial sample response\n#' Y_star <- Z*Y_1 + (1-Z)*Y_0 # True outcomes\n#' Y <- Y_star\n#' Y[R1==0] <- NA # Mask outcome of non-responders\n#'\n#' # Conduct Double Sampling\n#' Attempt <- rep(0, N)\n#' Attempt[is.na(Y)] <- rbinom(sum(is.na(Y)), 1, .5)\n#'\n#' R2 <- rep(0, N)\n#' R2[Attempt==1] <-  (Z*R2_1 + (1-Z)*R2_0)[Attempt==1]\n#'\n#' Y[R2==1 & Attempt==1] <- Y_star[R2==1 & Attempt==1]\n#'\n#' df <- data.frame(Y, Z, R1, Attempt, R2, strata)\n#'\n#' # Without post-stratification\n#' estimator_ds(Y, Z, R1, Attempt, R2, minY=1, maxY=5, data=df)\n#'\n#' # With post-stratification\n#' estimator_ds(Y, Z, R1, Attempt, R2, minY=1, maxY=5, strata=strata, data=df)\n#'\nestimator_ds <- function(Y, Z, R1, Attempt, R2, minY, maxY, strata = NULL, alpha = 0.05, data){\n  Y <-  eval(substitute(Y), data)\n  if(!is.numeric(Y)){stop(\"The outcome variable (Y) must be numeric.\")}\n  Z <-  eval(substitute(Z), data)\n  if(!all(Z %in% c(0,1))){stop(\"The treatment variable (Z) must be numeric and take values zero or one.\")}\n  R1 <-  eval(substitute(R1), data)\n  if(!all(R1 %in% c(0,1))){stop(\"The initial sample response variable (R1) must be numeric and take values zero or one.\")}\n  R2 <-  eval(substitute(R2), data)\n  if(!all(R2 %in% c(0,1))){stop(\"The follow-up sample response variable (R2) must be numeric and take values zero or one.\")}\n  Attempt <-  eval(substitute(Attempt), data)\n  if(!all(Attempt %in% c(0,1))){stop(\"The follow-up sample attempt variable (Attempt) must be numeric and take values zero or one.\")}\n\n  if(!is.numeric(minY) | !is.numeric(maxY)){stop(\"The minimum and maximum possible values of Y (minY and maxY) must be numeric\")}\n\n  if(is.null(strata)) {\n    n1_c_s <- sum(R1==1 & Z==0)\n    n1_t_s <- sum(R1==1 & Z==1)\n    n1_c <- sum(Z==0) # clean up\n    n1_t <- sum(Z==1)\n\n    p1_c <- n1_c_s/n1_c\n    p1_t <- n1_t_s/n1_t\n\n    y1m_c <- mean(Y[R1==1 & Z==0])\n    y1m_t <- mean(Y[R1==1 & Z==1])\n\n    n2_c <- sum(Attempt ==1 & Z ==0)\n    n2_t <- sum(Attempt ==1 & Z ==1)\n\n    p2_c <- sum(R2==1 & Z==0)/n2_c\n    p2_t <- sum(R2==1 & Z==1)/n2_t\n\n    y2m_nm_c <- mean(Y[R2==1 & Z==0])\n    y2m_nm_t <- mean(Y[R2==1 & Z==1])\n\n    s1_c <- sd(Y[R1==1 & Z==0])\n    s1_t <- sd(Y[R1==1 & Z==1])\n    s2_nm_c <- sd(Y[R2==1 & Z==0])\n    s2_nm_t <- sd(Y[R2==1 & Z==1])\n\n   # c1a_t <- c1r_t <- c2a_t <- c2r_t <- -99 # irrelevant\n\n    cis_out <- ds_manski_cis_2s(n1_t=n1_t,n2_t=n2_t,\n                                n1_c=n1_c,n2_c=n2_c,\n                                p1_t=p1_t,p2_t=p2_t,\n                                s1_t=s1_t,s1_c=s1_c,\n                                s2_nm_t=s2_nm_t,\n                                s2_nm_c=s2_nm_c,\n                                y1m_t=y1m_t,y1m_c=y1m_c,\n                                y2m_nm_t=y2m_nm_t,\n                                y2m_nm_c=y2m_nm_c,\n                                c1a_t=c1a_t,c1r_t=c1r_t,c2a_t=c2a_t,c2r_t=c2r_t,\n                                p1_c=p1_c,p2_c=p2_c,\n                                minY=minY,maxY=maxY,alpha=alpha)\n    return(cis_out)\n  }else{\n    # If there is a stratification variable, call estimator_ds recursively.\n  strata <-  eval(substitute(strata), data)\n  if(sum(is.na(strata))!=0){stop(\"The stratification variable (strata) must not contain any missing values.\")}\n\n  unique_strata <- unique(strata)\n  n_strata <- length(unique_strata)\n  m1_l_vec <- m1_u_vec <- v1_l_vec <- v1_u_vec <- proportions <- rep(NA, n_strata)\n\n  ds_df <- data.frame(Y, R1, Z, Attempt, R2, strata)\n\n  for(i in 1:n_strata){\n    ests <- estimator_ds(Y = Y, R1 = R1,Z = Z,\n                         Attempt = Attempt, R2 = R2,\n                         minY = minY, maxY = maxY, alpha = alpha,\n                         data=subset(ds_df, strata==unique_strata[i]))\n    m1_l_vec[i] <- ests[3]\n    m1_u_vec[i] <- ests[4]\n    v1_l_vec[i] <- ests[5]\n    v1_u_vec[i] <- ests[6]\n    proportions[i] <- mean(strata == unique_strata[i])\n  }\n\n  est_l <-  sum(m1_l_vec *proportions)\n  est_u <-  sum(m1_u_vec *proportions)\n\n  var_l <- sum(v1_l_vec *proportions^2)\n  var_u <- sum(v1_u_vec *proportions^2)\n\n  im_crit <- function(ca) abs(pnorm(ca + (est_u-est_l)/max(var_u,var_l))-pnorm(-ca)-(1-alpha))\n\n  sig <- optim(1.60,im_crit,method=\"Brent\",lower=1,upper=2)$par\n\n  return(c(ci_lower=est_l - sig*var_l^.5,\n           ci_upper=est_u + sig*var_u^.5,\n           low_est=est_l,\n           upp_est=est_u,\n           low_var=var_l,\n           upp_var=var_u))\n  }\n}\n\n\n#' Extreme Value (Manski) Bounds\n#'\n#' @param Y The (unquoted) outcome variable. Must be numeric.\n#' @param Z The (unquoted) assignment indicator variable. Must be numeric and take values 0 or 1.\n#' @param R The (unquoted) respose indicator variable. Must be numeric and take values 0 or 1.\n#' @param minY The minimum possible value of the outcome (Y) variable.\n#' @param maxY The maximum possible value of the outcome (Y) variable.\n#' @param strata A single (unquoted) variable that indicates which strata units are in.\n#' @param alpha The desired significance level. 0.05 by default.\n#' @param data A dataframe\n#'\n#' @return A results matrix\n#' @export\nestimator_ev <- function(Y, Z, R,  minY, maxY, alpha, data){\n  Y <-  eval(substitute(Y), data)\n  if(!is.numeric(Y)){stop(\"The outcome variable (Y) must be numeric.\")}\n  Z <-  eval(substitute(Z), data)\n  if(!all(Z %in% c(0,1))){stop(\"The treatment variable (Z) must be numeric and take values zero or one.\")}\n  R <-  eval(substitute(R), data)\n  if(!all(R %in% c(0,1))){stop(\"Theresponse variable (R) must be numeric and take values zero or one.\")}\n\n  if(!is.numeric(minY) | !is.numeric(maxY)){stop(\"The minimum and maximum possible values of Y (minY and maxY) must be numeric\")}\n\n  DV_l <- DV_u <- Y\n  DV_l[R==0] <- minY\n  DV_u[R==0] <- maxY\n\n  est_u <- mean(DV_u[Z==1]) - mean(DV_l[Z==0])\n  est_l <- mean(DV_l[Z==1]) - mean(DV_u[Z==0])\n\n  var_u <- var(DV_u[Z==1])/sum(Z==1) + var(DV_l[Z==0])/sum(Z==0)\n  var_l <- var(DV_l[Z==1])/sum(Z==1) + var(DV_u[Z==0])/sum(Z==0)\n\n  im_crit <- function(ca) abs(pnorm(ca + (est_u-est_l)/max(var_u,var_l))-pnorm(-ca)-(1-alpha))\n  sig <- optim(1.60,im_crit,method=\"Brent\",lower=1,upper=2)$par\n\n  return(c(ci_lower=est_l - sig*var_l^.5,\n           ci_upper=est_u + sig*var_u^.5,\n           low_est=est_l,\n           upp_est=est_u,\n           low_var=var_l,\n           upp_var=var_u))\n}\n\n\n",
    "created" : 1452194168106.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3226428085",
    "id" : "519B74EA",
    "lastKnownWriteTime" : 1452201640,
    "last_content_update" : 1452201640,
    "path" : "~/Documents/attrition/R/user_facing_functions.R",
    "project_path" : "R/user_facing_functions.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}