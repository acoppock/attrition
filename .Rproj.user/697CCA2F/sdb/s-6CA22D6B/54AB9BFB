{
    "collab_server" : "",
    "contents" : "# calculate sampling variance, p2 is assumed to be 1 always in this equation\n#' @export\nds_var <- function(n1,n2,p1,p2,s1,s2,y1m,y2m) p1*n1/n1^2 * s1^2 + ((1-p1)*n1)^2/(n2*n1^2)*s2^2 + ((1-p1)*n1)*p1*n1/n1^3*(y2m-y1m)^2\n\n# calculate manski bounds\n#' @export\nds_manski <- function(p1,p2,y1m,y2m_nm,minY,maxY) {\n\tconst1 <- p1*y1m + (1-p1)*p2*y2m_nm\n\tconst2 <- (1-p1)*(1-p2)\n\treturn(c(const1+const2*minY,const1+const2*maxY))\n}\n\n# calculate two-sample sampling variance\n#' @export\nds_var_2s <- function(treatment_vec,control_vec) {\n  ts_var <-\n  ds_var(treatment_vec[1],treatment_vec[2],\n         treatment_vec[3],treatment_vec[4],\n         treatment_vec[5],treatment_vec[6],\n         treatment_vec[7],treatment_vec[8]) +\n    ds_var(control_vec[1],control_vec[2],\n           control_vec[3],control_vec[4],\n           control_vec[5],control_vec[6],\n           control_vec[7],control_vec[8])\n  return(ts_var)\n}\n\n# estimate manski bounds, two-sample:\n#' @export\nds_manski_2s <- function(p1_t,p2_t,y1m_t,y2m_t,p1_c,p2_c,y1m_c,y2m_c,minY,maxY) {\n\tconst1_t <- p1_t*y1m_t + (1-p1_t)*p2_t*y2m_t\n\tconst2_t <- (1-p1_t)*(1-p2_t)\n\tconst1_c <- p1_c*y1m_c + (1-p1_c)*p2_c*y2m_c\n\tconst2_c <- (1-p1_c)*(1-p2_c)\n\treturn(c(const1_t+const2_t*minY - (const1_c+const2_c*maxY),const1_t+const2_t*maxY - (const1_c+const2_c*minY)))\n\t}\n\n#' @export\nds_manski_cis_2s <- function(n1_t,n2_t,n1_c,n2_c,\n                             p1_t,p2_t,s1_t,s2_nm_t,\n                             y1m_t,y2m_nm_t,\n                             c1a_t,c1r_t,c2a_t,c2r_t,\n                             p1_c,p2_c,\n                             s1_c,s2_nm_c,\n                             y1m_c,y2m_nm_c,\n                             minY,maxY,alpha) {\n\n  # compute 2nd round manski mean\n  gen_mean <- function(y2m_nm,p2,lower_bound=TRUE,minY,maxY){\n    if (lower_bound == TRUE){\n      return(p2*y2m_nm + (1-p2)*minY)\n    }else{\n      return(p2*y2m_nm+(1-p2)*maxY)\n    }\n  }\n  # compute 2nd round manski sd given prop, which bound, and mean\n  gen_var <- function(y2m_nm,s2_nm,p2,lower_bound=TRUE,minY,maxY) {\n    if (lower_bound==TRUE){\n      const <- minY\n    }else{\n      const <- maxY\n      wm <- gen_mean(y2m_nm,p2,lower_bound,minY,maxY)\n      # formula for combined var\n      return(p2*s2_nm^2 + p2*(y2m_nm-wm)^2 + (1-p2)*(const-wm)^2)\n    }\n  }\n\n    y2m_t_L <- gen_mean(y2m_nm_t,p2_t,lower_bound=TRUE,minY,maxY)\n    y2m_t_U <- gen_mean(y2m_nm_t,p2_t,lower_bound=FALSE,minY,maxY)\n    y2m_c_L <- gen_mean(y2m_nm_c,p2_c,lower_bound=TRUE,minY,maxY)\n    y2m_c_U <- gen_mean(y2m_nm_c,p2_c,lower_bound=FALSE,minY,maxY)\n\n    s2_t_L <- gen_var(y2m_nm_t,s2_nm_t,p2_t,lower_bound=TRUE,minY,maxY)^.5\n    s2_t_U <- gen_var(y2m_nm_t,s2_nm_t,p2_t,lower_bound=FALSE,minY,maxY)^.5\n    s2_c_L <- gen_var(y2m_nm_c,s2_nm_c,p2_c,lower_bound=TRUE,minY,maxY)^.5\n    s2_c_U <- gen_var(y2m_nm_c,s2_nm_c,p2_c,lower_bound=FALSE,minY,maxY)^.5\n\n    manski_bounds_est <- ds_manski_2s(p1_t,p2_t,y1m_t,y2m_nm_t,p1_c,p2_c,y1m_c,y2m_nm_c,minY,maxY)\n    lower_bound_est <- ds_manski_2s(p1_t,p2_t,y1m_t,y2m_nm_t,p1_c,p2_c,y1m_c,y2m_nm_c,minY,maxY)[1]\n    upper_bound_est <- ds_manski_2s(p1_t,p2_t,y1m_t,y2m_nm_t,p1_c,p2_c,y1m_c,y2m_nm_c,minY,maxY)[2]\n\n    lower_bound_var_est <- ds_var_2s(c(n1_t,n2_t,p1_t,p2_t,s1_t,s2_t_L,y1m_t,y2m_t_L),c(n1_c,n2_c,p1_c,p2_c,s1_c,s2_c_U,y1m_c,y2m_c_U))\n    upper_bound_var_est <- ds_var_2s(c(n1_t,n2_t,p1_t,p2_t,s1_t,s2_t_U,y1m_t,y2m_t_U),c(n1_c,n2_c,p1_c,p2_c,s1_c,s2_c_L,y1m_c,y2m_c_L))\n\n\n    im_crit <- function(ca) abs(pnorm(ca + (upper_bound_est-lower_bound_est)/max(upper_bound_var_est,lower_bound_var_est))-pnorm(-ca)-(1-alpha))\n\n    sig <- optim(1.60,im_crit,method=\"Brent\",lower=1,upper=2)$par\n\n    return(c(ci_lower=lower_bound_est - sig*lower_bound_var_est^.5,\n             ci_upper=upper_bound_est + sig*upper_bound_var_est^.5,\n             low_est=lower_bound_est,upp_est=upper_bound_est,\n             low_var=lower_bound_var_est,upp_var=upper_bound_var_est))\n  }\n\n#' find the n1,n2 (number of attempts to measure) that minimize width of Manski CIs\n#' @export\noptim_manski_2s <- function(p1_t,p2_t,s1_t,s2_nm_t,\n                            y1m_t,y2m_nm_t,\n                            c1a_t,c1r_t,c2a_t,c2r_t,\n                            p1_c,p2_c,s1_c,s2_nm_c,\n                            y1m_c,y2m_nm_c,\n                            c1a_c,c1r_c,c2a_c,c2r_c,\n                            budget,minY,maxY,\n                            mu=1e-04,niter=100,alpha=0.05) {\n\n\n  matout <- matrix(NA,nrow=niter,ncol=5)\n  colnames(matout) <- c(\"n1_t\",\"n2_t\",\"n1_c\",\"n2_c\",\"ci_width\")\n  iter <- 1\n\n  while(iter <= niter) {\n\n    #(c1a_t+c1r_t*p1_t)*n1_t + (c2a_t+c2r_t*p2_t)*n2_t + (c1a_c+c1r_c*p1_c)*n1_c + (c2a_c+c2r_c*p2_c)*n2_c = budget\n\n    starting_values <- .5*runif(4)*budget/c((c1a_t+c1r_t*p1_t),(c2a_t+c2r_t*p2_t*(1-p1_t)),(c1a_c+c1r_c*p1_c),(c2a_c+c2r_c*p2_c*(1-p1_c)))\n\n    n1g_t = starting_values[1]\n    n2g_t = starting_values[2]\n    n1g_c = starting_values[3]\n    n2g_c = starting_values[4]\n\n\n    # constraints\n    #- (c1a_t+c1r_t*p1_t)*n1_t - (c2a_t+c2r_t*p2_t)*n2_t - (c1a_c+c1r_c*p1_c)*n1_c - (c2a_c+c2r_c*p2_c)*n2_c + budget >= 0\n    # n1_t > 2\n    # n2_t > 2\n    # n1_c > 2\n    # n2_c > 2\n    # (1-p1_t)*n1_t - n2_t > 2\n    # (1-p1_c)*n1_c - n2_c > 2\n\n    constrMat <- rbind(c(-(c1a_t+c1r_t*p1_t),-(c2a_t+c2r_t*p2_t),-(c1a_c+c1r_c*p1_c),-(c2a_c+c2r_c*p2_c)),\n                       c(1,0,0,0),\n                       c(0,1,0,0),\n                       c(0,0,1,0),\n                       c(0,0,0,1),\n                       c((1-p1_t),-1,0,0),\n                       c(0,0,(1-p1_c),-1)\n    ) # are these working?\n    constrVec <- c(-budget,2,2,2,2,2,2)\n\n    # compute width of 95% CIs\n    ds_passthrough_2s <- function(ns,p1_t,p2_t,s1_t,s2_nm_t,\n                                  y1m_t,y2m_nm_t,\n                                  c1a_t,c1r_t,c2a_t,c2r_t,\n                                  p1_c,p2_c,s1_c,s2_nm_c,\n                                  y1m_c,y2m_nm_c,\n                                  minY,maxY,alpha){\n      diff(ds_manski_cis_2s(ns[1],ns[2],ns[3],ns[4],p1_t,p2_t,s1_t,s2_nm_t,y1m_t,y2m_nm_t,c1a_t,c1r_t,c2a_t,c2r_t,p1_c,p2_c,s1_c,s2_nm_c,y1m_c,y2m_nm_c,minY,maxY,alpha))\n    }\n\n    optimD <- try(constrOptim(c(n1g_t,n2g_t,n1g_c,n2g_c),\n                              ds_passthrough_2s,grad=NULL,ui=constrMat,ci=constrVec,\n                              p1_t=p1_t,p2_t=p2_t,\n                              s1_t=s1_t,s2_nm_t=s2_nm_t,\n                              y1m_t=y1m_t,y2m_nm_t=y2m_nm_t,\n                              c1a_t=c1a_t,c1r_t=c1r_t,\n                              c2a_t=c2a_t,c2r_t=c2r_t,\n                              p1_c=p1_c,p2_c=p2_c,\n                              s1_c=s1_c,s2_nm_c=s2_nm_c,\n                              y1m_c=y1m_c,y2m_nm_c=y2m_nm_c,\n                              minY=minY,maxY=maxY,alpha=alpha,\n                              outer.iterations=1000,outer.eps = .Machine$double.eps^.5,mu=mu),silent=TRUE)\n\n    if(!is.character(optimD)) {\n      cat(iter,\"\")\n      matout[iter,] <- c(n1_t = optimD$par[1],n2_t = optimD$par[2],n1_c = optimD$par[3],n2_c = optimD$par[4],ci_width=optimD$value)\n      iter <- iter + 1\n    }\n\n  }\n  return(matout[order(matout[,5]),])\n}\n\n\n",
    "created" : 1452194165749.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1774855898",
    "id" : "54AB9BFB",
    "lastKnownWriteTime" : 1452201640,
    "last_content_update" : 1452201640,
    "path" : "~/Documents/attrition/R/estimators.R",
    "project_path" : "R/estimators.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}